# Компоненты памяти
 - PC Registers — локальная область для каждого потока, содержащая адрес инструкции JVM, которую поток выполняет в
   данный момент.
- Java Stacks (или стек) — тоже локальная область для каждого потока. Она хранит параметры, локальные переменные и адреса,
   доступные во время вызовов методов.
- Heap (англ. «куча») — это общая область для всех потоков. Она содержит объекты, метаданные классов, массивы и объекты,
   которые создаются во время работы программы. Эта область создаётся при запуске JVM и уничтожается при завершении работы виртуальной машины.
   Вы можете контролировать объём кучи, используя определённые флаги настроек. При работе с ней нужно соблюдать осторожность:
   размер кучи влияет на производительность программы. Эта область не освобождается автоматически.
   Ей управляет сборщик мусора (GC), который следит за её объёмами.
 - Method Area (англ. «область метода») — общая область для всех потоков. Создаётся при запуске JVM. Она хранит
   структуры для каждого класса, такие как код конструкторов и методов, данные методов и так далее.
- Run-Time Constant Pool (от англ. «пул констант времени выполнения») — это структура данных в памяти для каждого класса или типа. Пул констант действует как таблица символов при связывании загруженных классов. Иными словами, пул содержит константы, необходимые для запуска кода определённого класса.
- Native Method Stacks (англ. «стеки нативных методов»). стек для методов, написанных не на джаве

**Стек** — это область памяти, которая хранит «оперативные» данные, необходимые для работы в данный момент.
Каждый раз, когда вызывается метод, в памяти стека появляется новый блок — **фрейм стека** («стековый кадр»). 
В него помещается информация, используемая в этом методе, такая как массив локальных переменных, список операндов и 
ссылки на пул констант. 

![image](https://github.com/user-attachments/assets/d5ae84a8-3a86-495a-9a03-541f25c1d7b5)

## Сборка мусора 
### Слабая гипотеза о поколениях
*Новички уходТ первыми - чем моложе объект, тем быстрее сборщик мусора заметит его и удалит*

Вероятность удаления объекта снижатеся с его возврастом, сборщик мусора считает, что если объект находитс в куче долго и его
использовали много раз, значит, он нужен программе.

Таким образом, все объекты в куче делятся на:
1. младшее поколении
2. старшее поколение.

Процесс сборки мусора может выполняться в нескольких режимах:
- в режиме малой сборки (minor GC ). В этом режиме выполняется очистка в области младшего поколения
- режиме основной сборки (major GC ). Выполняется очистка старшего поколения
-  режиме полной сборки (full GC). Очистка двух поколений

Перед началом работы сборщики мусора выясняют, в каком состоянии находятся объекты в куче. Они проверяют, 
кто ещё может пригодиться, а кому пора освободить место. Если на объекты ссылаются, значит, они полезны и нужны программе. 
Такие объекты называются **достижимыми** (reachability). 

### Подходы сборки мусора
1.Метод подсчёта ссылок - для каждого объекта в куче создаётся счётчик ссылок. Сборщик мусора обходит все объекты и оставляет только те, у которых счётчик 
больше нуля
2. Метод флагов (метод маркировки и выметания) - для каждого объекта в памяти хранится бит, указывающий на достижимость.
Вначале все объекты, кроме корневых, помечаются как недостижимые. Затем рекурсивно просматриваются и помечаются 
достижимыми те объекты, которые доступны из корневых объектов. Если объект не прошёл проверку и не получил метку, 
он считается недостижимым.
3. Метод карточного стода (наиболее эффективный) 

### Stop the world (STW)
Полная остановка всех потоков программы для безопасной сборки мусора. Остановки происходит в безопасных точках

## Алгоритм сборки мусора
радел младшего поколения состоит из нескольих частей:
1. Eden — пространство, куда попадают новые объекты.
2. S0, S1 — пространство, куда попадают уцелевшие объекты.

Типы сборщиков в hotSpot:
- Последовательные сборщики (англ. Serial). Используют один поток для выполнения всей работы по сборке мусора.
  Они лучше всего подходят для однопроцессорных машин или в приложениях с небольшими наборами данных (примерно до 100 МБ).
  Запуск сборки мусора требует полной остановки приложения — остановки мира.
- Параллельные сборщики (англ. Parallel). Используют несколько потоков для сборки мусора. Они подходят для
  многопроцессорных компьютеров и приложений с большим набором данных при достаточном объёме памяти.
  Запуск сборки мусора также требует полной остановки приложения.
- Конкурентные сборщики (англ. Concurrent). Это многопоточные сборщики мусора. Большую часть своей работы они
  выполняют, не останавливая потоки приложения, а конкурируя с ними. То есть конкурентные сборщики сводят к минимуму
  задержку приложения во время остановки мира.


### Serial GC
Делит кучу на четыре части, три из которых принадлежат младшему поколению: Eden, S0 и S1. Основные его характеристики такие же, как и для всей группы последовательных сборщиков. 
![image](https://github.com/user-attachments/assets/40d064f2-8e2c-4259-9dfa-5a9828bfc27a)


### Parallel GC
Делит кучу аналогично, но работает параллельно - сборкой мусора занимаются несколько потоков.
Также сборщик может самостоятельно подстраиваться под параметры производительности
![image](https://github.com/user-attachments/assets/f07c4253-5106-4e5b-a010-db55afdee58b)


### CMS GC
— это первая реализация сборщика конкурентного типа.

CMS GC, как и другие сборщики, делит кучу на несколько частей. С единственным различием. Область старшего поколения тут
называется **Tenured** (от англ. «штатный»). В отличие от последовательных сборщиков CMS GC удаляет ненужные объекты во время работы приложения.
тобы начать сборку мусора, CMS GC не ждёт, когда область старшего поколения заполнится. Он постоянно выполняет всю основную работу в фоновом режиме. Но всё же это не исключает коротких остановок потоков. 
Остановки основных потоков приложения выполняются:
 - для начальной пометки и поиска живых объектов (от англ. initial mark) старшего поколения (напрямую доступных из корней);
 - для повторной пометки живых объектов (от англ. remark) старшего поколения (напрямую доступных из корней).
![image](https://github.com/user-attachments/assets/6a584a52-9b29-4543-bb19-203103341aec)

### Современные сборщики
В современных сборщиках память разбивается на множество разделов одинакового размера. Эти разделы могут распределяться в случайном порядке и менять свою принадлежность тому или иному поколению. 
Иногда в области старшего поколения появляются **громадные регионы**. Это происходит при слиянии обычных разделов. В громадных регионах хранятся большие объекты, которые не перемещаются и могут быть 
удалены при сборке мусора. 

### G1
G1 работает в двух основных фазах сборки мусора: 
 - Чистка области младшего поколения. Работа по сборке мусора проводится не над всем регионом младшего поколения. Выбираются только те части, в которых скопилось больше мусора. Перед этим сборщик анализирует результаты предыдущих сборок и поведение приложения. Размер региона для очистки определяется таким образом, чтобы весь процесс уложился в определённое время.
 - Смешанная сборка мусора. Конкурентный сборщик не может очистить область старшего поколения отдельно от младшего. Смешанная сборка запускается тогда, когда память заполняется почти до определённого показателя. Тогда к набору регионов младшего поколения, подлежащих очистке, добавляется некоторое количество регионов старшего поколения. При этом сборщик учитывает, что время для очистки ограничено.
После сборки мусора живые объекты, найденные в процессе очистки, переходят в новые области памяти, уплотняя их. Освободившееся пространство повторно используется приложением. 
Параллельно с работой основного приложения G1 составляет список живых объектов. Этот процесс называется **циклом пометки**. Он проходит по следующему алгоритму: 
1. Concurrent marking (от англ. «одновременная маркировка»). Пометка живых объектов в куче без остановки приложения.
2. Remark (от англ. «пометка»). Дополнительный поиск живых объектов с остановкой приложения. Используется метод карточного стола.
3. Cleanup (от англ. «уборка»). Этот этап проходит в два шага. На первом происходит очистка вспомогательных структур учёта ссылок на объекты. При этом приложение останавливается. Второй шаг проходит без остановки приложения. В это время происходит поиск пустых регионов для размещения новых объектов.

### Выбор сборщика мусора
1. Если приложение не предъявляет требований ко времени задержки, предоставьте выбор сборщика мусора самой JVM. В большинстве случаев настройки по умолчанию отлично работают. Чтобы повысить производительность программы, достаточно увеличить размер кучи.
2. Если в приложении небольшой набор данных и оно работает на одном процессоре без требований ко времени задержки, вам подойдёт последовательный сборщик.
3.Если пиковая производительность приложения в приоритете, а требований ко времени задержки нет, следует остановиться на параллельном сборщике.
4.Если время отклика приложения важнее, чем общая пропускная способность, а паузы при сборке мусора должны быть короче секунды, то ваш выбор — G1.
5. Если в приоритете время отклика и в работе задействована куча большого размера, советуем выбрать ZGC.
