# Транзакции
Это способ выполнения запросов, гарантирующий, что в случае ошибки все сделаенные в рамках транзакции
изменения будут отменены. Транзакция объединяет последовательность действий в одну операцию по принципу всё или ничего.
Или все команды в рамках транзакции будут выполнены до конца, или ни одна инструкция не выполнится.

## Характеристики транзакции - ACID
  1. A-Атомарность - все операции транзакции выполняются атомарно, то есть *целиком*. Если выполнены лишь некоторые инструкции, транзакция считается неуспешной и полностью откатывается.
  2. С-Согласованность - транзакция переводит БД из одного согласованного состояния в дургое
  3. I-Изолированность - каждая транзакция выполняется сама по себе, без взаимодействия с другими.
     По стандарту SQL существует 4 уровня изоляции:
     1. Read Unicommited (присутсвует аномалия "грязное чтение")
     2. Read Commited (Присутсвует аномания "Неповторяющееся чтение" - при повторном чтении
        считывается обновленная строка, которая ранее была заокмичена)
     4. Readpeatable Read (аномалия "Чтение фантомов")
     5. Serializable
  5. D-Надежность - по завершении транзакции все внесённые ею изменения фиксируются в бд

Про аномалии и ACID <https://youtu.be/ecBJrsqvSdg?si=axekBDyqA4H0MRTO>

## Транзакции в SQL
Команда *BEGIN* начинает транзакцию, все операторы после этой команды и до *COMMIT* или *ROLLBACK* будут выполняться в ней. 

*COMMIT* - фиксирует текующую транзакцию: все выполненые изменения становятся видимыми для других и гарантировано сохрнатся в случае сбоя

```
  BEGIN; -- шаг 1: начинаем транзакцию
  
  UPDATE accounts SET balance = balance - 100.00 WHERE name = 'София';
  UPDATE bank_balance SET balance = balance - 100.00 WHERE name = (SELECT bank_name FROM accounts WHERE name = 'София'); -- шаг 2: списываем средства со счёта Софии
  
  UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Тимофей';
  UPDATE bank_balance SET balance = balance + 100.00 WHERE name = (SELECT bank_name FROM accounts WHERE name = 'Тимофей'); -- шаг 3: зачисляем средства на счёт Тимофея
  
  COMMIT; -- шаг 4: завершаем транзакцию 
```

*ROLLBACK* - откатывает транзакцию, что приведёт к отмене всех произведенных ею изменений

```
  BEGIN; -- шаг 1: начинаем транзакцию

  UPDATE accounts SET balance = balance - 99.99 WHERE name = 'София'; -- шаг 2: списываем средства со счёта Софии
  
  ROLLBACK; -- шаг 3: упс! Что-то пошло не так: не та сумма. Отменяем транзакцию
```

## Транзакции в Java
<https://www.baeldung.com/transaction-configuration-with-jpa-and-spring>
1) Добавляем код бина
   ```
   @Bean
    public JpaTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory);
        return transactionManager;
    }
   ```
2) Подключение механизма трензакционности для Spring
   ```
    @Configuration
    @EnableTransactionManagement // включает управление транзакциями и обработку соответствующих аннотаций
    @EnableJpaRepositories(basePackages = "ru.practicum")
    public class PersistenceConfig{
        // здесь остальные настройки
    } 
   ```
### Транзакционные методы и классы
  Методы, в которых используются транзакции, называют транзакционными. Для этого их помечают 
  аннотацией @Transactional.
  Если метод доступен только для чтения, то используем параметр аннотации readOnly = true
  Пример: 

  ```
    @Override
    @Transactional(readOnly = true)
    public List<UserDto> getAllUsers() {
        return repository.findAll()
                .stream()
                .map(UserDto::from)
                .collect(Collectors.toList());
  ```
Дополнительные настройки Аннотации: 
1) Уровень изоляции: @Transactional(isolation = Isolation.SERIALIZABLE)
2) Режим "Только для чтения"
3) Время ожидания для операции, завершенной транзакции
4) Указать откат метода (rollbackFor = Exception.class) - по умолчанию стоит RubtimeException
5) Область видимости: по умолчанию аннотация используется только на public методах

### Вложенные транзакции
 С точки зрения БД, вложенных транзакций не существует, а проблемы, возникающие с их использованием, должен решать код приложения. 
Чтобы работать со внутренними аннотациями доавляются параметр propagation(распространение)
```
  @Transactional(propagation = Propagation.REQUIRED)
  public void updateUsers(){
      // код метода 
  } 
```

Параметр может принимать следующие значения: 
  - REQUIRED - если транзакции не существует, Spring создат новую. Если метод вызываеся из другого
    транзакционного метода, будет использована уже существующая аннотация
  - SUPPORTS - выполнять метод в режиме транзакции нужно тогда, когда она уже существует
  - MANDATORY - метод будет выполнен при наличии транакции, если транзакции не существует, метод сгенерирует исключение
  - NEVER - метод не выполнится, если транзакция существует
  - NOT_SUPPORTED - существующая транзакция будет приостновлена и метод выполнится без транзакции
  - REQUIRES_NEW - существующая транзакция приостанавливается и создается новая, метод будет выполнен в рамках новой транзакции
  - NESTED -  этот режим не просто приостановит существующую транзакцию. Он создаст в ней точку сохранения (англ. savepoint), в которую база данных вернётся, даже если вызываемый метод сгенерирует исключение.
