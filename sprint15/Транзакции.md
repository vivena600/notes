# Транзакции
Это способ выполнения запросов, гарантирующий, что в случае ошибки все сделаенные в рамках транзакции
изменения будут отменены. Транзакция объединяет последовательность действий в одну операцию по принципу всё или ничего.
Или все команды в рамках транзакции будут выполнены до конца, или ни одна инструкция не выполнится.

## Характеристики транзакции - ACID
  1. A-Атомарность - все операции транзакции выполняются атомарно, то есть *целиком*. Если выполнены лишь некоторые инструкции, транзакция считается неуспешной и полностью откатывается.
  2. С-Согласованность - транзакция переводит БД из одного согласованного состояния в дургое
  3. I-Изолированность - каждая транзакция выполняется сама по себе, без взаимодействия с другими.
  5. D-Надежность - по завершении транзакции все внесённые ею изменения фиксируются в бд

Про аномалии и ACID <https://youtu.be/ecBJrsqvSdg?si=axekBDyqA4H0MRTO>

## Транзакции в SQL
Команда *BEGIN* начинает транзакцию, все операторы после этой команды и до *COMMIT* или *ROLLBACK* будут выполняться в ней. 

*COMMIT* - фиксирует текующую транзакцию: все выполненые изменения становятся видимыми для других и гарантировано сохрнатся в случае сбоя

```
  BEGIN; -- шаг 1: начинаем транзакцию
  
  UPDATE accounts SET balance = balance - 100.00 WHERE name = 'София';
  UPDATE bank_balance SET balance = balance - 100.00 WHERE name = (SELECT bank_name FROM accounts WHERE name = 'София'); -- шаг 2: списываем средства со счёта Софии
  
  UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Тимофей';
  UPDATE bank_balance SET balance = balance + 100.00 WHERE name = (SELECT bank_name FROM accounts WHERE name = 'Тимофей'); -- шаг 3: зачисляем средства на счёт Тимофея
  
  COMMIT; -- шаг 4: завершаем транзакцию 
```

*ROLLBACK* - откатывает транзакцию, что приведёт к отмене всех произведенных ею изменений

```
  BEGIN; -- шаг 1: начинаем транзакцию

  UPDATE accounts SET balance = balance - 99.99 WHERE name = 'София'; -- шаг 2: списываем средства со счёта Софии
  
  ROLLBACK; -- шаг 3: упс! Что-то пошло не так: не та сумма. Отменяем транзакцию
```

## Транзакции в Java
<https://www.baeldung.com/transaction-configuration-with-jpa-and-spring>
1) Добавляем код бина
   ```
   @Bean
    public JpaTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory);
        return transactionManager;
    }
   ```
2) Подключение механизма трензакционности для Spring
   ```
    @Configuration
    @EnableTransactionManagement // включает управление транзакциями и обработку соответствующих аннотаций
    @EnableJpaRepositories(basePackages = "ru.practicum")
    public class PersistenceConfig{
        // здесь остальные настройки
    } 
   ```
### Транзакционные методы и классы
  Методы, в которых используются транзакции, называют транзакционными. Для этого их помечают 
  аннотацией @Transactional.
  Если метод доступен только для чтения, то используем параметр аннотации readOnly = true
  Пример: 

  ```
    @Override
    @Transactional(readOnly = true)
    public List<UserDto> getAllUsers() {
        return repository.findAll()
                .stream()
                .map(UserDto::from)
                .collect(Collectors.toList());
  ```
Дополнительные настройки Аннотации: 
1) Уровень изоляции: @Transactional(isolation = Isolation.SERIALIZABLE)
2) Режим "Только для чтения"
3) Время ожидания для операции, завершенной транзакции
4) Указать откат метода (rollbackFor = Exception.class) - по умолчанию стоит RubtimeException
5) Область видимости: по умолчанию аннотация используется только на public методах

#### Свойства транзакций
*режим доступа*:
1. READ WRITE (значение по умолчанию) - выполнение всех команд
2. READ ONLY - только чтение, выполнение команд INSERT, UPDATE, DELETE, CREATE и других будет запрещено.
   
*свойства изоляции*:
1. READ COMMITTED (значение по умолчанию) - В текущей транзакции будут видны только те строки, которые были зафиксированы до начала её выполнения.
2. REPEATABLE READ -  читающая транзакция не увидит изменений данных, которые были прочитаны
 ею ранее
3. SERIALIZABLE - транзакции полностью изоллируются друг от друга, каждая выполняется так, как
   будто параллельных транзакций не существует
4. READ UNCOMMITTED - Если несколько параллельных транзакций попытаются изменить одну и ту же строку таблицы, в окончательном варианте строка будет иметь то значение, которое определено всем набором успешно выполненных транзакций. В PostgreSQL этот уровень не реализован.

Set Transaction в sql <https://postgrespro.ru/docs/postgrespro/12/sql-set-transaction>

#### Аномалии
  - «Грязное» чтение (англ. dirty reads) — в результатах запроса появляются промежуточные результаты параллельной транзакции, которая ещё не завершилась.
  - Фантомное чтение (англ. phantom reads) — в результатах повторяющегося запроса появляются и исчезают строки, которые в данный момент модифицирует параллельная транзакция.
  - Неповторяющееся чтение (англ. non-repeatable reads) — запрос с одними и теми же условиями даёт неодинаковые результаты в рамках транзакции.
  - Потерянное обновление (англ. lost update) — две параллельные транзакции меняют одни и те же данные, при этом итоговый результат обновления предсказать невозможно. С течением времени базы данных научились решать эту проблему, но теоретически она по-прежнему возможна.

Изоляции через аннотацию
```
  @Transactional(isolation = Isolation.DEFAULT) 
```

1. DEFAULT — значение по умолчанию. Транзакция создаётся с уровнем изоляции, заданным в настройках базы данных. Использование этого значения требует контроля, потому что БД может быть настроена не так, как ожидает разработчик.
2. READ_COMMITTED — этот уровень изоляции предотвращает проблему «грязного» чтения.
3. REPEATABLE_READ — этот уровень предотвращает проблему «грязного» и неповторяющегося чтения.
4. SERIALIZABLE — на этом уровне не возникает перечисленных проблем. Однако из-за необходимости последовательно выполнять часть параллельных транзакций существенно падает скорость взаимодействия с БД.
5. READ_UNCOMMITTED — соответствует низшему уровню изоляции. На нём возможны все перечисленные проблемы, возникающие в работе с параллельными транзакциями.

### Вложенные транзакции
 С точки зрения БД, вложенных транзакций не существует, а проблемы, возникающие с их использованием, должен решать код приложения. 
Чтобы работать со внутренними аннотациями доавляются параметр propagation(распространение)
```
  @Transactional(propagation = Propagation.REQUIRED)
  public void updateUsers(){
      // код метода 
  } 
```

Параметр может принимать следующие значения: 
  - REQUIRED - если транзакции не существует, Spring создат новую. Если метод вызываеся из другого
    транзакционного метода, будет использована уже существующая аннотация
  - SUPPORTS - выполнять метод в режиме транзакции нужно тогда, когда она уже существует
  - MANDATORY - метод будет выполнен при наличии транакции, если транзакции не существует, метод сгенерирует исключение
  - NEVER - метод не выполнится, если транзакция существует
  - NOT_SUPPORTED - существующая транзакция будет приостновлена и метод выполнится без транзакции
  - REQUIRES_NEW - существующая транзакция приостанавливается и создается новая, метод будет выполнен в рамках новой транзакции
  - NESTED -  этот режим не просто приостановит существующую транзакцию. Он создаст в ней точку сохранения (англ. savepoint), в которую база данных вернётся, даже если вызываемый метод сгенерирует исключение.
