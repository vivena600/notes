## @Entity
Используется для отметки классов-сущностей. У каждой сузности должен быть идентификатор, отражающий её уникальность
Для этого можно исспользовать оннотацию **@id**
Аннотацией **@Transient** помечают поля и методы, которые не должны проецироваться на таблицу в бд.
ORM будет игнорировать поля с такой аннтацией
## @Table и @Column
Эти аннотации используются для настройки сопоставления между классов сущности и таблицей в бд
Параметры в ссузности и поля в бд скорее всего будут называться по разному, поэтому таким образом мы показваем ORM 
какие данные подставлять при маппинге
```
  @Entity
  @Table(name = "users", schema = "public")
  public class User {
  
      @Id
      private Long id;
  
      @Column(name = "first_name", nullable = false)
      private String firstName;
  
      @Column(name = "last_name")
      private String lastName;
  
      private String email;
  
  } 
```
Также в аннотации @Column можно задавать ограничения
## @Enumerated
Указывает, что поле таблтцы будет иметь тип Enum 
Доступно два вида сохранения:
1. EnumType.STRING - полученные данные сохранятся  виде строки (state.name())
2. EnumType.ORDINAL - сохранит порядковый номер элемента перечисления (state.ordinal())
```
  @Enumerated(EnumType.STRING)
  private UserState state;
```

# @GeneratedValue
Указывает, что будет сгенерировано значение для первичного ключа
```
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
```
Стратегии генерации: 
1. IDENTITY - бд генерирует уникальный id автоматически
2. SEQUENCE - использует последовательность из бд
3. TABLE - использует отдельную таблицу в бд для хранения последнего ID
4. AUTO - Hibernate сам выбирает стратегию
5. UUID - генерирует идентификатор согласно стандарту RFC4122, подходит для систем где требуетчя уникальостьданных в разных БД

| Стратегия   | Зависит от БД       | Пакетная вставка | Производительность | Уникальность в распределённых системах |
|-------------|--------------------|------------------|--------------------|----------------------------------------|
| `IDENTITY`  | Да                 | ❌ Нет           | Средняя            | ❌ Нет                                 |
| `SEQUENCE`  | Да (PG, Oracle)    | ✅ Да            | Высокая            | ❌ Нет                                 |
| `TABLE`     | Нет                | ✅ Да            | Низкая             | ❌ Нет                                 |
| `AUTO`      | Да                 | Зависит от выбора| Зависит от выбора  | ❌ Нет                                 |
| `UUID`      | Нет                | ✅ Да            | Высокая            | ✅ Да                                  |

<https://www.geeksforgeeks.org/hibernate-generatedvalue-annotation-in-jpa/>

# @ElementCollection
в Java JPA позволяет определить связь «один ко многим» между сущностью и коллекцией простых или встраиваемых типов.
Позволяет маппить коллекции, списки, массивы и тд.

```
  @Entity
  @Table(name="user")
  class User  {
     @Id
     @Column(name="id")
     public Integer id;
  
     @ElementCollection
     public List<String> messages;
  }
```

Все поля Entity-класса, которые содержат много элементов и помечаются с помощью аннотации @ElementCollection содержатся в базе данных в специальной вспомогательной таблице. 
Эта таблица может содержать данные двух типов: 
1. Упорядочные (List, Map)
2. Неупорялочные (Set)
При помощи аннотации **@CollectionTable** мы можем задать имя этой таблицы явно

```
    @ElementCollection
    @CollectionTable(name="tags", joinColumns=@JoinColumn(name="item_id"))
    @Column(name="name")
    private Set<String> tags = new HashSet<>();
```
С помощью аннотации @CollectionTable определено, какую именно таблицу нужно использовать (таблица tags), 
а также по  какой колонке связаны строки таблицы tags со строкой таблицы items — по item_id.
