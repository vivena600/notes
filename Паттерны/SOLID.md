# SOLID
Большая часть информации взята из <https://www.youtube.com/watch?v=TxZwqVTaCmA&t=1327s>

Примеры <https://skillbox.ru/media/code/principy-solid-chto-eto-i-pochemu-ih-ispolzuyut-vse-senory/>

## S - Single responsibility principle 
Принцип единой ответсвенности 

*Один класс(сущность) решает одну задачу*

Преимущества: 
1. Докомпозиция (вырастает читабельность кода)
2. Проще вносить изменения
3. Избавляет от анипаттерна GodObject
4. Класс инкапсулирует решение одной задачи

## O - Open closed principle
Принцип открытости/закрытости

*Классы, модули, сущности должна быть открыты для расширения, но закрыты для изменения*
То есть функционал должен добавляться не за счёт изменения старых сущностей, а при помощи
доавления новой сущности путём композиции, наследования и реализовывать функионал уже там 

Преимущества: 
1. Нет необходимости в регрессии
2. Меньше вероятность ошибок

Чтобы этот принцип хорошо работал, на этапе начала разработки необходимо правильно выделить абстракции

## L - Single substitution principle
Приницп подстановки Барбары Лисков

*Наследуемый класс должен дополнять, а не замещать поведение базового класса*

## I - Interface segregation principle 
Приницип разделения интерфейса 

*Программные сущности не должны зависеть то методов, которые они не используют*
То есть нужно разбивать наши толстые программные сущности, на более маленькие - отвечающие за 
часть определенной задачи
Неправильно: 
![image](https://github.com/user-attachments/assets/13d70fc0-1e8a-48f9-83a0-500914958285)

Преимущества: 
1. Избавляем програмные сущности от методов, которые они не используем
2. Получаем более предсказуемую работу
3. Код становится менее связанным

## D - Dependency inversion principle
Приницп инверсии зависимости

*Модуль выского уровня не должен зависеть от модуля более низкого уровня, все они должны зависеть от
абстракции, а абстракции в это время не должны зависеть от деталей, в свою очередь детали должны 
зависеть от абстракци*

